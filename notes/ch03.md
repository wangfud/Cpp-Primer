# 第三章 字符串、向量和数组

## using声明
- 使用某个命名空间：例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。
- 头文件中不应该包含`using`声明。这样使用了该头文件的源码也会使用这个声明，可以会产生名称冲突。。

## string
- 标准库类型`string`表示可变长的字符序列。
- `#include <string>`，然后 `using std::string;`
- **string对象**：注意，不同于字符串字面值。
  
### 定义和初始化string对象

初始化`string`对象的方式：

| 方式 | 解释 |
| -- | -- |
| `string s1` | 默认初始化，`s1`是个空字符串 |
| `string s2(s1)` | `s2`是`s1`的副本 |
| `string s2 = s1` | 等价于`s2(s1)`，`s2`是`s1`的副本 |
| `string s3("value")` | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本 |
| `string s4(n, 'c')` | 把`s4`初始化为由连续`n`个字符`c`组成的串 |

- 拷贝初始化（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象。
- 直接初始化（direct initialization）：通过括号给对象赋值。

### string对象上的操作

`string`的操作：

| 操作 | 解释 |
|-----|-----|
| `os << s` | 将`s`写到输出流`os`当中，返回`os` |
| `is >> s` | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is` |
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is` |
| `s.empty()` | `s`为空返回`true`，否则返回`false` |
| `s.size()` | 返回`s`中字符的个数 |
| `s[n]` | 返回`s`中第`n`个字符的引用，位置`n`从0计起 |
| `s1+s2` | 返回`s1`和`s2`连接后的结果 |
| `s1=s2` | 用`s2`的副本代替`s1`中原来的字符 |
| `s1==s2` | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2` | 同上 |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） |

- string io：
    - 执行读操作`>>`：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。
    - `getline`：读取一整行，**包括空白符**。
```c++
string world;
while(getline(cin,world)){
    cout<<world<<endl;
}
//输入换行符触发，同时触发getline的换行符会被丢弃，world中不会包含任何换行符。
```
- `s.size()`返回的是`string::size_type`类型，记住是一个**无符号**类型的值，不要和`int`混用

- 字符串比较规则：按位比较ASCII码
- **字符串字面值和string是不同的类型。**
  - `s1+s2`使用时，保证至少一侧是string类型。`string s1 = "hello" + "world" // 错误，两侧均为字符串字面值`

### 处理string对象中的字符

- **ctype.h vs. cctype**：C++修改了c的标准库，名称为去掉`.h`，前面加`c`。
  
  > 如c++版本为`cctype`，c版本为`ctype.h`
  
  - **尽量使用c++版本的头文件**，即`cctype`

`cctype`头文件中定义了一组标准函数：

| 函数 | 解释 |
|-----|-----|
| `isalnum(c)` | 当`c`是字母或数字时为真 |
| `isalpha(c)` | 当`c`是字母时为真 |
| `iscntrl(c)` | 当`c`是控制字符时为真 |
| `isdigit(c)` | 当`c`是数字时为真 |
| `isgraph(c)` | 当`c`不是空格但可以打印时为真 |
| `islower(c)` | 当`c`是小写字母时为真 |
| `isprint(c)` | 当`c`是可打印字符时为真 |
| `ispunct(c)` | 当`c`是标点符号时为真 |
| `isspace(c)` | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)` | 当`c`是大写字母时为真 |
| `isxdigit(c)` | 当`c`是十六进制数字时为真 |
| `tolower(c)` | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c` |
| `toupper(c)` | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c` |

- 遍历字符串：使用**范围for**（range for）语句： `for (auto c: str)`，或者 `for (auto &c: str)`使用引用直接改变字符串中的字符。 （C++11）
```c++
//遍历输出字符串的每个字符
string str("some string");
for(auto c:str){
    cout<<c<<endl;
}

//案例：使用范围for语句和ispunct统计string对象中标点符号的个数。
string s("hello world!!!");
decltype(s.size()) punct_cnt = 0;

//统计s中标点符号的个数
for(auto c:s){
    if(ispunct(c)){
        ++punct_cnt;
    }
}
cout<< punct <<endl;
```
- 字符串**下表运算符**[]，如`str[x]`,[]输入参数为`string::size_type`类型，给出`int`整型也会自动转化为该类型,返回值为该位置上字符的引用。

```cpp
//使用下表执行迭代：依次处理字符串中字符，直到结尾或者遇到空白字符。
string str("some string");
for (decltype(str.size()) index = 0; index != str.size() && !isspace(str[index]); ++index){
    str[index] = toupper(str[index]);
}
cout<<str<<endl;//输出：SOME string


```



## vector
- vector是一个**容器**，也是一个类模板；
- 使用vector必须包：`#include <vector>` 然后 `using std::vector;`
- 容器：包含其他对象的对象。
- 类模板：本身不是类，但可以**实例化（instantiation）**出一个类。 
  - `vector`是一个模板， `vector<int>`是一个类型。
- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`。
- vector中的元素如果还是vector，则定义方式有如下区别：

```c++
//c++11
vector<vector<int>> vv;
//老版本
vector<vector<int> > vv;  //老版本必须在外层vector对象右尖括号的左边添加一个空格。
```



### 定义和初始化vector对象

初始化`vector`对象的方法

| 方法 | 解释 |
|-----|-----|
| `vector<T> v1` | **默认初始化：**`v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)` | **拷贝初始化：**`v2`中包含有`v1`所有元素的副本 |
| `vector<T> v2 = v1` | **拷贝初始化：**等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本 |
| `vector<T> v3(n, val)` | **创建指定数量的元素**：`v3`包含了n个重复的元素，每个元素的值都是`val` |
| `vector<T> v4(n)` | **值初始化**：n个元素，每个元素初始值为T的默认初始化值，T为int初始值就为0. |
| `vector<T> v5{a, b, c...}`  | **列表初始化**：`v5`包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}` |

- 列表初始化： 

```c++
// （C++11）
vector<string> v{"a", "an", "the"};    //只能使用花括号
```

- 对于值初始化方式，如果vector对象中元素类型T不支持默认初始化，则必须提供初始的元素值，否则无法通过只提供元素个数来完成初始化。

- vector初始化中通过**圆括号**提供的值<u>**构造vector对象**</u>，通过**花括号**来确定每个元素的**<u>初始值</u>**。
  - 注意：如果使用了花括号，但是提供的值又不能用来初始化元素，则该值表示构造vector。

```c++
//以下两个例子中虽然使用了花括号，但不是列表初始化。
vector<string> v1{10};//v1有10个默认初始化的元素。
vector<string> v2{10,"hi"};//v2有10个值为hi的元素。
```



### 向vector对象中添加元素

- `v.push_back(e)` 在尾部增加元素。
- vector对象能够高效自动扩展。
> 建议：先定义一个空的vector，在运行时向其中添加具体值。

- **如果循环体内包含有向vector对象添加元素的语句，则不能使用范围for循环。**

### 其他vector操作

`vector`支持的操作：

| 操作 | 解释 |
|-----|-----|
| `v.emtpy()` | 如果`v`不含有任何元素，返回真；否则返回假 |
| `v.size()` |  返回`v`中元素的个数|
| `v.push_back(t)` | 向`v`的尾端添加一个值为`t`的元素 |
| `v[n]` | 返回`v`中第`n`个位置上元素的**引用** |
| `v1 = v2` | 用`v2`中的元素拷贝替换`v1`中的元素  |
| `v1 = {a,b,c...}` | 用列表中元素的拷贝替换`v1`中的元素 |
| `v1 == v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2` | 同上 |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较 |

- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。

```c++
vector<int> ivec;
for(decltype(ivec.size()) ix=0;ix!=10;++ix){
    //ivec[ix] = ix;      //严重错误，ivec不包含任何元素
    ivec.push_back(ix);   //应该使用push_back添加元素。
}
```

> - 注意：只能对已存在元素执行下标操作。试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知值。
>
> - 确保下标合法的一种手段就是尽可能使用范围for语句（或迭代器）。

## 迭代器iterator

- **容器**：可以包含其他对象；但所有的对象必须类型相同。
- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素。

- 所有标准库容器都可以使用迭代器。
- 类似于指针类型，迭代器也提供了对容器元素对象的间接访问。
- 迭代器有有效和无效之分：
  - 有效迭代器指迭代器指向某个元素，或者尾元素的下一个位置（尾哨兵）。
  - 其他指向情况都属于无效迭代器。

### 使用迭代器

- `vector<int>::iterator iter`。
- `auto b = v.begin();`返回指向第一个元素的迭代器。
- `auto e = v.end();`返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。
- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器。
- 使用解引用符`*`访问迭代器指向的元素。试图解引用一个非法迭代器或者尾后迭代器是未被定义的行为。

```c++
//将一个字符串首字母改成大写
string s("some thing");
if(s.begin()!=s.end()){
    auto it = s.begin();
    *it = toupper(*it);
}
cout<<s<<endl;//Some thing
```

- 对迭代器使用++运算符可以使迭代器移动到下一个元素。（不能对end迭代器使用*和++运算符）

```c++
string s("some thing");
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it) {
    *it = toupper(*it);
}
cout<<s<<endl;//SOME thing
```

- 养成使用迭代器和`!=`的习惯（泛型编程）。向上一个例子中的：`it != s.end()`

> 在c++中习惯使用!= 判断循环的结尾，只有下标运算符才习惯使用<运算符判断结尾。但是c++中不是所有的容器类型都支持下标运算符。

- 标准库类型使用`iterator`和`const_iterator`来标识迭代器类型。
  - `const_iterator`：只能读取容器内元素不能修改元素。相反`iterator`可读可写。
  - 如果容器（vector/string）是一个常量，只能使用`const_iterator`，否则两者都能使用。
  - c++11引入了cbein和cend两个函数可以专门用来获取一个`非常量向量的const_iterator`。

```c++
vector<int> v;
const vector<int> cv;
auto b = v.begin();    //b是vector<int>::iterator类型
auto bc = cv.begin();  //bc是vector<int>::const_iterator类型。
auto ltv = v.cbegin(); //ltv是vector<int>::const_iterator类型。
```

- **箭头运算符**：` 解引用 + 成员访问`，例如判断向量中字符串是否为空：`it->empty()等价于(*it).empty()`。
- **谨记**：但凡是使用了**迭代器**的循环体，都**不要**向迭代器所属的容器**添加元素**。

标准容器迭代器的运算符:

| 运算符 | 解释 |
|-----|-----|
| `*iter` | 返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem` | 等价于`(*iter).mem` |
| `++iter` | 令`iter`指示容器中的下一个元素 |
| `--iter` | 令`iter`指示容器中的上一个元素 |
| `iter1 == iter2` | 判断两个迭代器是否相等 |

### 迭代器运算

`vector`和`string`迭代器支持的运算：

| 运算符 | 解释 |
|-----|-----|
| `iter + n` | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n` | 迭代器减去一个整数仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n` | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1` |
| `iter1 -= n` | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1` |
| `iter1 - iter2` | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器 |

- **difference_type**：保证足够大以存储任何两个迭代器对象间的距离，可正可负。

```cpp
vector<int> vi{1,2,3,4,5,6,7,8,9};
    auto lt1 = vi.begin()+3;
    auto lt2 = vi.begin()+6;
    auto d1 = lt2-lt1; //d1是difference_type类型，是一个带符号整型
    auto d2 = lt1-lt2;
    cout<<d1<<endl;//3
    cout<<d2<<endl;//-3

```



## 数组

- 相当于vector的低级版，**长度固定**。

> 如果不清楚元素的确切个数，请使用vector

### 定义和初始化内置数组

- 初始化：`数组类型 变量名[数组长度]`

>  注意：
>
> - 长度必须是const表达式，或者不写，让编译器自己推断。
> - 定义数组必须指定数组类型，不允许使用auto关键字由初始值的列表推断类型。
> - 和vector一样，数组元素应该为对象，不存在引用的数组。

![image-20240410100629001](ch03.assets/image-20240410100629001.png)

- 可以对数组进行列表初始化，此时允许忽略数字的维度，编译器会自动更具初始值计算数组的长度。

  > 如果即指定了维度，有提供了初始化列表，初始化列表的长度应小于定义的维度。数组其余元素初始化成默认值。

```c++
int a1[5] = {1,2,3};//a1前三个元素是1,2,3，其余元素为0
```

- 字符数组可以使用字符串字面值进行初始化。

```c++
char a1[] = {'c','+','+'};			//没有空字符
char a2[] = {'c','+','+','\0'};		//有空字符
char a3[] = "c++";					//自动添加结尾空字符，等价于a2
char a4[3] ="c++";					//错误：没有空间可存放空字符。 
```

- 数组不允许直接赋值给另一个数组。

- 理解复杂数组：

```c++
int arr[] = {1,2,3};
int *ptrs[10];                  //ptrs是含有10个整数指针的数组
int &refs[10];                  //错误：不存在引用的数组
int (*Parray)[3] = &arr;        //Parray指向一个含有3个整数的数组。
int (&arrRef) [3] = arr;        //arrRef引用一个含有3个元素的数组。
```

- 想要理解数组声明的含义：最好的办法是从数组的名字开始按照由内向外的顺序阅读。

```c++
int *(&array)[10] = ptrs;//arr是数组引用，该数组有10个指针。`
```

> 按照由内向外的熟阅读上述语句：先查看array的左边，指导array是一个引用。在查看array的右边，知道array引用对象是一个大小为10的数组。最后再观察左边确定数组的元素类型为指向int的指针。

### 访问数组元素

- 数组也支持使用下表和范围for语句来访问。

- 数组下标的类型：`size_t`：
  - 是一种及其相关的无符号类型 。
  - 其特点是足够大，以便能表示内存中任意对象的大小。
  - 定义在cstddef头文件中（c语言是stddef.h头文件）。
- 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 。
- 大多数常见的安全问题都源于缓冲区溢出错误。当数组或者其他类似的数据结构的下标越界并视图访问非法内存区域时，就会产生此类错误。

### 数组和指针

- 使用数组时，编译器一般会把他转换成指向数组首元素的指针。

```c++
int nums[] = {1,2,3};
int *p = &nums[0]; 		//获取首元素的指针
int *q = nums;
cout<<(p==q)<<endl;		//1
```

- 数组的操作也是指针的操作,故当使用auto或decltype通过数组变量进行类型推断是有如下区别：
  - auto推断结果为数组第一个元素的指针。
  - decltype推断结果为和推断目标数组同类型且长度相同的数组。

```c++
int ia[] = {1,2,3};
auto ia2(ia); //ia2的类型为 int* ,指向ia的第一个元素。
auto ia3 = ia; //和ia2等价
auto ia4(&ia[0]); //和ia2等价
decltype(ia) ia5; //ia5的类型为 int[3] ,长度为3的数组。

//解决方法：使用引用类型
auto &ia6(ia);  //ia6的类型为 int &[3]的数组。
ia[2] = 100;
cout<<ia6[2]<<endl;//100  (此时ia6可以看做是一个ia的引用，共享同一份数据。)
ia6[2] = -100;
cout<<ia[2]<<endl;//-100
```

- vector和string的迭代器支持的运算，数组名指针也全部支持。

```c++
int ia[] = {1,2,3};
cout<<*ia<<endl; 			//1
cout<<*(ia+2)<<endl;		//3
```

- 数组并不支持迭代器的begin和end方法，但是可以通过数组的指针来进行模拟。

```c++
int ia[] = {1, 2, 3};
auto bein = ia;
auto end = &ia[3];  //用指向arr尾元素的下一个位置来标识end尾后指针。
//遍历数组。
for (auto begin = ia, end = &ia[3]; begin != end; begin++) {
    cout << *begin << endl;
}
```

- c++11在标准库中引入两个函数：begin和end，可以方便的获取数组的首指针和尾后指针。

```c++
int ia[] = {1, 2, 3};
auto beg = begin(ia);
auto last = end(ia);
//使用while循环遍历。
while (beg != last) {
    cout << *beg << endl;
    beg++;
}
```

> 注意：尾后指针不能执行解引用和递增操作。

- 两个数组指针相减的结果类型是一种名为`ptrdiff_t`的标准库类型，定义在cstddef头文件中，本质上是一种带符号类型。
- 只有指向同一个数组的元素（包括数组尾后指针）的两个指针才能使用关系运算符进行比较。不相关的两个指针比较毫无意义。

### 下标和指针

- 对数组执行下标运算其实是对指向数组元素的指针执行下标运算。

```c++
int ia[] = {0, 2, 4, 6, 8};
int i = ia[2];              //得到ia+2所指向的元素。

int *p = ia;
i = *(p+2);//等价于i = ia[2]
```

- 数组内置下标运算符所用的索引值不是无符号类型，这一点和vector和string均不同。内置的下标运算符也可以处理负值下标。

```c++
int *p = &ia[2]; //p指向索引为2的元素
int k = p[-2];  //指向ia[0]
```

### C风格字符串

- 从C继承来的字符串。
- 用空字符结束（`\0`）。
- 对大多数应用来说，使用标准库 `string`比使用C风格字符串更安全、更高效。
- 获取 `string` 中的 `cstring` ： `const char *str = s.c_str();` 。

C标准库String函数，定义在`<cstring>` 中：

| 函数 | 介绍 |
|-----|-----|
| `strlen(p)` | 返回`p`的长度，空字符不计算在内 |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1` |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1` |

- c标准库的string函数不负责验证其字符串参数，同时此类函数的指针必须指向以空字符作为结束的数组。

```cpp
char ca[] = {'c','+','+'};		//不以\0为结束
cout << strlen(ca) << endl;			//严重错误：ca不以空字符结束。
```

### 与旧代码的接口

很多c++程序在标准库出现之前就已经写好了，他们肯定没有string和vector。而且有些c++程序实际上是与c语言或其他语言的接口程序，当然也无法使用c++标准库。因此现代的c++程序需要和那些充满了数组或c分割字符串代码进行衔接。

- 混用string和c风格字符串

  - c风格字符和string的转化

  ```c++
  char s1[] = {'a','b','c','\0'};
  string s2(s1); //c风格字符串变为string
  
  
  string s3 = "def";
  const char *s4 = s3.c_str();  //string转化为c风格字符串
  
  //string和c风格字符串可以直接相加
  cout << s1+s3<<endl;//abcdef
  s3 += s1;   //string支持对c风格字符串的符合赋值运算
  s1 +=s2;    // 错误：c风格字符串无该功能
  ```

- 使用数组初始化vector对象：

```c++
int int_arr[] = {0,1,2,3,4};
vector<int> ivec(begin(int_arr),end(int_arr));
```

- `尽量使用vector和迭代器，少用数组。尽量使用string，避免使用c风格的基于数组的字符串。`

## 多维数组

- **多维数组的初始化**： `int ia[3][4] = {{0,1,2,3}, ...}`。

```c++
//方式1：
int ia1[2][2] = {
        {1,2},
        {3,4}
};
//方式2：
int ia2[2][2] = {1,2,3,4};
//方式3：
int ia3[2][2] = {{0},{1}};  //显示的指定每行首元素，其余元素执行默认初始化
//方式4：
int ia4[2][2] = {0,1};      //显示初始化第一行，其余元素执行默认初始化

```

### 多维数组的遍历

- 使用普通for循环遍历

```cpp
constexpr size_t rowCnt = 2, colCnt = 2;
    int ia[rowCnt][colCnt];
    for (size_t i = 0; i != rowCnt; i++) {
        for (size_t j = 0; j != colCnt; j++) {
            ia[i][j] = i * colCnt + j;
        }
    }
```

- 使用范围for循环遍历：

```c++
for(auto &row:ia1){
    for(auto &col:row){
        cout<< col <<" ";
    }
    cout<<endl;
}

/*
输出:
1 2
3 4
*/
```



- 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是**引用**类型。

## 指针vs引用

- 引用总是指向某个对象，定义引用时没有初始化是错的。
- 给引用赋值，修改的是该引用所关联的对象的值，而不是让引用和另一个对象相关联。

## 指向指针的指针

- 定义： `int **ppi = &pi;`
- 解引用：`**ppi`

## 动态数组

- 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间。
- 定义： `int *pia = new int[10];` 10可以被一个变量替代。
- 释放： `delete [] pia;`，注意不要忘记`[]`。





